name: Sync Fork main + tags

on:
  # 每6小时检查一次上游更新（仅处理 main 与 tags）
  schedule:
    - cron: '0 */6 * * *'  # 每 6 小时运行一次（0时、6时、12时、18时）

  # 如需在提交到 dev-home 时也触发，可取消注释并将分支改为你的默认分支名
  # push:
  #   branches:
  #     - dev-home

  # 允许手动触发，仅支持 force_sync
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'Force sync even if there are conflicts'
        required: false
        type: boolean
        default: false

jobs:
  sync:
    runs-on: ubuntu-latest
    # 防止并发运行导致冲突
    concurrency:
      group: sync-upstream
      cancel-in-progress: false
    
    steps:
      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Configure push auth (optional PAT)
        id: auth
        env:
          PAT_TOKEN: ${{ secrets.PAT_WORKFLOW }}
          PAT_USER: ${{ secrets.PAT_USER }}
        run: |
          if [ -n "$PAT_TOKEN" ]; then
            USER="${PAT_USER:-${GITHUB_ACTOR}}"
            git remote set-url origin "https://${USER}:${PAT_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            echo "🔐 Using PAT for pushes (workflow scope)"
            echo "using_pat=true" >> $GITHUB_OUTPUT
          else
            echo "ℹ️ No PAT provided, will push with GITHUB_TOKEN (may fail for commits touching .github/workflows)"
            echo "using_pat=false" >> $GITHUB_OUTPUT
          fi

      - name: Add upstream remote
        run: |
          # 上游仓库地址
          UPSTREAM_REPO="https://github.com/Wei-Shaw/claude-relay-service.git"
          
          echo "Adding upstream remote: $UPSTREAM_REPO"
          git remote add upstream $UPSTREAM_REPO || git remote set-url upstream $UPSTREAM_REPO
          # 获取上游所有引用与标签
          git fetch --prune upstream 
          git fetch --tags --force upstream

      - name: Check for updates (main only)
        id: check
        run: |
          TARGET_BRANCH="main"
          echo "Target branch: $TARGET_BRANCH"
          echo "target_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT

          # 确保上游 main 分支存在
          if ! git show-ref --verify --quiet refs/remotes/upstream/$TARGET_BRANCH; then
            echo "❌ Upstream branch $TARGET_BRANCH not found"
            echo "Available upstream branches:"
            git branch -r | grep upstream || echo "No upstream branches found"
            exit 1
          fi
          
          # 确保本地/远程存在 main 分支；若 fork 尚无 main，则基于上游创建
          if git show-ref --verify --quiet refs/remotes/origin/$TARGET_BRANCH; then
            git checkout $TARGET_BRANCH || git checkout -b $TARGET_BRANCH origin/$TARGET_BRANCH
          else
            echo "origin/$TARGET_BRANCH not found; creating from upstream/$TARGET_BRANCH"
            git checkout -B $TARGET_BRANCH upstream/$TARGET_BRANCH
            git push -u origin $TARGET_BRANCH
          fi

          # 检查是否有新的提交
          LOCAL_COMMIT=$(git rev-parse HEAD)
          UPSTREAM_COMMIT=$(git rev-parse upstream/$TARGET_BRANCH)
          
          echo "Local commit: $LOCAL_COMMIT"
          echo "Upstream commit: $UPSTREAM_COMMIT"
          
          if [ "$LOCAL_COMMIT" != "$UPSTREAM_COMMIT" ]; then
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "📦 Found new commits in upstream repository"
            git log --oneline HEAD..upstream/$TARGET_BRANCH | head -20 || true
          else
            echo "has_updates=false" >> $GITHUB_OUTPUT
            echo "✅ Already up to date with upstream"
          fi

      - name: Sync main branch
        if: steps.check.outputs.has_updates == 'true'
        run: |
          TARGET_BRANCH="${{ steps.check.outputs.target_branch }}"
          echo "🔄 Syncing $TARGET_BRANCH branch..."
          
          # 确保我们在正确的分支上
          git checkout $TARGET_BRANCH || git checkout -b $TARGET_BRANCH origin/$TARGET_BRANCH
          
          # 保存本地更改（如果有）
          git stash save "Auto-stash before sync" || true
          
          # 尝试自动合并
          if git merge upstream/$TARGET_BRANCH --no-edit --allow-unrelated-histories; then
            echo "✅ Successfully merged upstream changes"
            # 尝试恢复本地更改
            git stash pop || true
            git push origin $TARGET_BRANCH
          elif [ "${{ github.event.inputs.force_sync }}" == "true" ]; then
            echo "⚠️ Conflicts detected, using force sync..."
            git reset --hard upstream/$TARGET_BRANCH
            git push --force-with-lease origin $TARGET_BRANCH
          else
            echo "❌ Merge conflicts detected. Attempting automatic resolution..."
            # 尝试使用上游版本解决冲突
            git reset --hard upstream/$TARGET_BRANCH
            git push --force-with-lease origin $TARGET_BRANCH || {
              echo "Failed to sync. Please resolve manually or run with force_sync=true"
              exit 1
            }
          fi

      - name: Sync upstream tags to fork
        run: |
          echo "🔖 Syncing tags from upstream -> origin"
          # 更新本地的上游标签
          git fetch upstream --tags --force --prune
          
          # 逐个推送，避免因单个标签失败导致整个步骤失败
          FAILED_TAGS=()
          SYNCED_TAGS=()
          for tag in $(git tag -l | sort -V); do
            if git push origin "refs/tags/$tag:refs/tags/$tag" --force; then
              echo "✔️  pushed $tag"
              SYNCED_TAGS+=("$tag")
            else
              echo "❌ failed $tag"
              FAILED_TAGS+=("$tag")
            fi
          done
          
          echo "Synced tags: ${#SYNCED_TAGS[@]} | Failed: ${#FAILED_TAGS[@]}"
          # 将失败标签写入临时文件，供汇总使用
          printf "%s\n" "${FAILED_TAGS[@]}" > failed-tags.txt

      - name: Create sync report
        if: always()
        run: |
          echo "## 📊 Sync Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Updates Found**: ${{ steps.check.outputs.has_updates }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Branch**: ${{ steps.check.outputs.target_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Using PAT**: ${{ steps.auth.outputs.using_pat }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check.outputs.has_updates }}" == "true" ]; then
            echo "### Recent commits from upstream:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            git log --oneline HEAD..upstream/${{ steps.check.outputs.target_branch }} | head -10 >> $GITHUB_STEP_SUMMARY || echo "No new commits" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Tags synced" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            git tag -l | sort | tail -20 >> $GITHUB_STEP_SUMMARY || true
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f failed-tags.txt ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Tags failed to push" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat failed-tags.txt | sed '/^$/d' >> $GITHUB_STEP_SUMMARY || true
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "If failures mention 'without workflows permission', add a PAT with 'workflow' scope as secret 'PAT_WORKFLOW' (and optional 'PAT_USER')." >> $GITHUB_STEP_SUMMARY
          fi
