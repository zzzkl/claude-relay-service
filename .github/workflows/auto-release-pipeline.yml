name: Auto Release Pipeline

on:
  push:
    branches:
      - main

permissions:
  contents: write
  packages: write

jobs:
  release-pipeline:
    runs-on: ubuntu-latest
    # è·³è¿‡ç”±GitHub Actionsåˆ›å»ºçš„æäº¤ï¼Œé¿å…æ­»å¾ªç¯
    if: github.event.pusher.name != 'github-actions[bot]' && !contains(github.event.head_commit.message, '[skip ci]')
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Check if version bump is needed
      id: check
      run: |
        # æ£€æµ‹æ˜¯å¦æ˜¯åˆå¹¶æäº¤
        PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
        PARENT_COUNT=$((PARENT_COUNT - 1))
        echo "Parent count: $PARENT_COUNT"
        
        if [ "$PARENT_COUNT" -gt 1 ]; then
          # åˆå¹¶æäº¤ï¼šè·å–åˆå¹¶è¿›æ¥çš„æ‰€æœ‰æ–‡ä»¶å˜æ›´
          echo "Detected merge commit, getting all merged changes"
          # è·å–åˆå¹¶åŸºå‡†ç‚¹
          MERGE_BASE=$(git merge-base HEAD^1 HEAD^2 2>/dev/null || echo "")
          if [ -n "$MERGE_BASE" ]; then
            # è·å–ä»åˆå¹¶åŸºå‡†åˆ° HEAD çš„æ‰€æœ‰å˜æ›´
            CHANGED_FILES=$(git diff --name-only $MERGE_BASE..HEAD)
          else
            # å¦‚æœæ— æ³•è·å–åˆå¹¶åŸºå‡†ï¼Œä½¿ç”¨ç¬¬äºŒä¸ªçˆ¶æäº¤
            CHANGED_FILES=$(git diff --name-only HEAD^2..HEAD)
          fi
        else
          # æ™®é€šæäº¤ï¼šè·å–ç›¸å¯¹äºä¸Šä¸€ä¸ªæäº¤çš„å˜æ›´
          CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD 2>/dev/null || git diff --name-only $(git rev-list --max-parents=0 HEAD)..HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # æ£€æŸ¥æ˜¯å¦åªæœ‰æ— å…³æ–‡ä»¶ï¼ˆ.md, docs/, .github/ç­‰ï¼‰
        SIGNIFICANT_CHANGES=false
        while IFS= read -r file; do
          # è·³è¿‡ç©ºè¡Œ
          [ -z "$file" ] && continue
          
          # æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦å¿½ç•¥çš„æ–‡ä»¶
          if [[ ! "$file" =~ \.(md|txt)$ ]] && 
             [[ ! "$file" =~ ^docs/ ]] && 
             [[ ! "$file" =~ ^\.github/ ]] &&
             [[ "$file" != "VERSION" ]] &&
             [[ "$file" != ".gitignore" ]] &&
             [[ "$file" != "LICENSE" ]]; then
            echo "Found significant change in: $file"
            SIGNIFICANT_CHANGES=true
            break
          fi
        done <<< "$CHANGED_FILES"
        
        if [ "$SIGNIFICANT_CHANGES" = true ]; then
          echo "Significant changes detected, version bump needed"
          echo "needs_bump=true" >> $GITHUB_OUTPUT
        else
          echo "No significant changes, skipping version bump"
          echo "needs_bump=false" >> $GITHUB_OUTPUT
        fi

    - name: Get current version
      if: steps.check.outputs.needs_bump == 'true'
      id: get_version
      run: |
        # è·å–æœ€æ–°çš„tagç‰ˆæœ¬
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        TAG_VERSION=${LATEST_TAG#v}
        
        # è·å–VERSIONæ–‡ä»¶ä¸­çš„ç‰ˆæœ¬
        FILE_VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "VERSION file: $FILE_VERSION"
        
        # æ¯”è¾ƒtagç‰ˆæœ¬å’Œæ–‡ä»¶ç‰ˆæœ¬ï¼Œå–è¾ƒå¤§å€¼
        function version_gt() { test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"; }
        
        if version_gt "$FILE_VERSION" "$TAG_VERSION"; then
          VERSION="$FILE_VERSION"
          echo "Using VERSION file: $VERSION (newer than tag)"
        else
          VERSION="$TAG_VERSION"
          echo "Using tag version: $VERSION (newer or equal to file)"
        fi
        
        echo "Current version: $VERSION"
        echo "current_version=$VERSION" >> $GITHUB_OUTPUT

    - name: Calculate next version
      if: steps.check.outputs.needs_bump == 'true'
      id: next_version
      run: |
        VERSION="${{ steps.get_version.outputs.current_version }}"
        
        # åˆ†å‰²ç‰ˆæœ¬å·
        IFS='.' read -r -a version_parts <<< "$VERSION"
        MAJOR="${version_parts[0]:-0}"
        MINOR="${version_parts[1]:-0}"
        PATCH="${version_parts[2]:-0}"
        
        # é»˜è®¤é€’å¢patchç‰ˆæœ¬
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
        
        echo "New version: $NEW_VERSION"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Update VERSION file
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        echo "${{ steps.next_version.outputs.new_version }}" > VERSION
        
        # é…ç½®git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # æäº¤VERSIONæ–‡ä»¶ - æ·»åŠ  [skip ci] ä»¥é¿å…å†æ¬¡è§¦å‘
        git add VERSION
        git commit -m "chore: sync VERSION file with release ${{ steps.next_version.outputs.new_tag }} [skip ci]"

    # æ„å»ºå‰ç«¯å¹¶æ¨é€åˆ° web-dist åˆ†æ”¯
    - name: Setup Node.js
      if: steps.check.outputs.needs_bump == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: web/admin-spa/package-lock.json

    - name: Build Frontend
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        echo "Building frontend for version ${{ steps.next_version.outputs.new_version }}..."
        cd web/admin-spa
        npm ci
        npm run build
        echo "Frontend build completed"

    - name: Push Frontend Build to web-dist Branch
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        # åˆ›å»ºä¸´æ—¶ç›®å½•
        TEMP_DIR=$(mktemp -d)
        echo "Using temp directory: $TEMP_DIR"
        
        # å¤åˆ¶æ„å»ºäº§ç‰©åˆ°ä¸´æ—¶ç›®å½•
        cp -r web/admin-spa/dist/* "$TEMP_DIR/"
        
        # æ£€æŸ¥ web-dist åˆ†æ”¯æ˜¯å¦å­˜åœ¨
        if git ls-remote --heads origin web-dist | grep -q web-dist; then
          echo "Checking out existing web-dist branch"
          git fetch origin web-dist:web-dist
          git checkout web-dist
        else
          echo "Creating new web-dist branch"
          git checkout --orphan web-dist
        fi
        
        # æ¸…ç©ºå½“å‰ç›®å½•ï¼ˆä¿ç•™ .gitï¼‰
        git rm -rf . 2>/dev/null || true
        
        # å¤åˆ¶æ„å»ºäº§ç‰©
        cp -r "$TEMP_DIR"/* .
        
        # æ·»åŠ  README
        cat > README.md << EOF
        # Claude Relay Service - Web Frontend Build
        
        This branch contains the pre-built frontend assets for Claude Relay Service.
        
        **DO NOT EDIT FILES IN THIS BRANCH DIRECTLY**
        
        These files are automatically generated by the CI/CD pipeline.
        
        Version: ${{ steps.next_version.outputs.new_version }}
        Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        EOF
        
        # åˆ›å»º .gitignore æ–‡ä»¶ä»¥æ’é™¤ node_modules
        cat > .gitignore << EOF
        node_modules/
        *.log
        .DS_Store
        .env
        EOF
        
        # åªæ·»åŠ å¿…è¦çš„æ–‡ä»¶ï¼Œæ’é™¤ node_modules
        git add --all -- ':!node_modules'
        git commit -m "chore: update frontend build for v${{ steps.next_version.outputs.new_version }} [skip ci]"
        git push origin web-dist --force
        
        # åˆ‡æ¢å›ä¸»åˆ†æ”¯
        git checkout main
        
        # æ¸…ç†ä¸´æ—¶ç›®å½•
        rm -rf "$TEMP_DIR"
        
        echo "Frontend build pushed to web-dist branch successfully"

    - name: Install git-cliff
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        wget -q https://github.com/orhun/git-cliff/releases/download/v1.4.0/git-cliff-1.4.0-x86_64-unknown-linux-gnu.tar.gz
        tar -xzf git-cliff-1.4.0-x86_64-unknown-linux-gnu.tar.gz
        chmod +x git-cliff-1.4.0/git-cliff
        sudo mv git-cliff-1.4.0/git-cliff /usr/local/bin/

    - name: Generate changelog
      if: steps.check.outputs.needs_bump == 'true'
      id: changelog
      run: |
        # è·å–ä¸Šä¸€ä¸ªtagä»¥æ¥çš„æ›´æ–°æ—¥å¿—
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -n "$LATEST_TAG" ]; then
          # æ’é™¤VERSIONæ–‡ä»¶çš„æäº¤
          CHANGELOG=$(git-cliff --config .github/cliff.toml $LATEST_TAG..HEAD --strip header | grep -v "bump version" | sed '/^$/d' || echo "- ä»£ç ä¼˜åŒ–å’Œæ”¹è¿›")
        else
          CHANGELOG=$(git-cliff --config .github/cliff.toml --strip header || echo "- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ")
        fi
        echo "content<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create and push tag
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        NEW_TAG="${{ steps.next_version.outputs.new_tag }}"
        git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
        git push origin HEAD:main "$NEW_TAG"

    - name: Prepare image names
      id: image_names
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        DOCKER_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
        if [ -z "$DOCKER_USERNAME" ]; then
          DOCKER_USERNAME="weishaw"
        fi

        DOCKER_IMAGE=$(echo "${DOCKER_USERNAME}/claude-relay-service" | tr '[:upper:]' '[:lower:]')
        GHCR_IMAGE=$(echo "ghcr.io/${{ github.repository_owner }}/claude-relay-service" | tr '[:upper:]' '[:lower:]')

        {
          echo "docker_image=${DOCKER_IMAGE}"
          echo "ghcr_image=${GHCR_IMAGE}"
        } >> "$GITHUB_OUTPUT"

    - name: Create GitHub Release
      if: steps.check.outputs.needs_bump == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.next_version.outputs.new_tag }}
        name: Release ${{ steps.next_version.outputs.new_version }}
        body: |
          ## ğŸ³ Docker é•œåƒ
          
          ```bash
          docker pull ${{ steps.image_names.outputs.docker_image }}:${{ steps.next_version.outputs.new_tag }}
          docker pull ${{ steps.image_names.outputs.docker_image }}:latest
          docker pull ${{ steps.image_names.outputs.ghcr_image }}:${{ steps.next_version.outputs.new_tag }}
          docker pull ${{ steps.image_names.outputs.ghcr_image }}:latest
          ```
          
          ## ğŸ“¦ ä¸»è¦æ›´æ–°
          
          ${{ steps.changelog.outputs.content }}
          
          ## ğŸ“‹ å®Œæ•´æ›´æ–°æ—¥å¿—
          
          æŸ¥çœ‹ [æ‰€æœ‰ç‰ˆæœ¬](https://github.com/${{ github.repository }}/releases)
        draft: false
        prerelease: false
        generate_release_notes: true

    # è‡ªåŠ¨æ¸…ç†æ—§çš„tagså’Œreleasesï¼ˆä¿æŒæœ€è¿‘50ä¸ªï¼‰
    - name: Cleanup old tags and releases
      if: steps.check.outputs.needs_bump == 'true'
      continue-on-error: true
      env:
        TAGS_TO_KEEP: 50
      run: |
        echo "ğŸ§¹ è‡ªåŠ¨æ¸…ç†æ—§ç‰ˆæœ¬ï¼Œä¿æŒæœ€è¿‘ $TAGS_TO_KEEP ä¸ªtag..."
        
        # è·å–æ‰€æœ‰ç‰ˆæœ¬tagå¹¶æŒ‰ç‰ˆæœ¬å·æ’åºï¼ˆä»æ—§åˆ°æ–°ï¼‰
        echo "æ­£åœ¨è·å–æ‰€æœ‰tags..."
        ALL_TAGS=$(git ls-remote --tags origin | grep -E 'refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$' | awk '{print $2}' | sed 's|refs/tags/||' | sort -V)
        
        # æ£€æŸ¥æ˜¯å¦è·å–åˆ°tags
        if [ -z "$ALL_TAGS" ]; then
          echo "âš ï¸ æœªæ‰¾åˆ°ä»»ä½•ç‰ˆæœ¬tag"
          exit 0
        fi
        
        TOTAL_COUNT=$(echo "$ALL_TAGS" | wc -l)
        
        echo "ğŸ“Š å½“å‰tagç»Ÿè®¡ï¼š"
        echo "- æ€»æ•°: $TOTAL_COUNT"
        echo "- é…ç½®ä¿ç•™: $TAGS_TO_KEEP"
        
        if [ "$TOTAL_COUNT" -gt "$TAGS_TO_KEEP" ]; then
          DELETE_COUNT=$((TOTAL_COUNT - TAGS_TO_KEEP))
          echo "- å°†è¦åˆ é™¤: $DELETE_COUNT ä¸ªæœ€æ—§çš„tag"
          
          # è·å–è¦åˆ é™¤çš„tagsï¼ˆæœ€è€çš„ï¼‰
          TAGS_TO_DELETE=$(echo "$ALL_TAGS" | head -n "$DELETE_COUNT")
          
          # æ˜¾ç¤ºå°†è¦åˆ é™¤çš„ç‰ˆæœ¬èŒƒå›´
          OLDEST_TO_DELETE=$(echo "$TAGS_TO_DELETE" | head -1)
          NEWEST_TO_DELETE=$(echo "$TAGS_TO_DELETE" | tail -1)
          echo ""
          echo "ğŸ—‘ï¸ å°†è¦åˆ é™¤çš„ç‰ˆæœ¬èŒƒå›´ï¼š"
          echo "- ä»: $OLDEST_TO_DELETE"
          echo "- åˆ°: $NEWEST_TO_DELETE"
          
          echo ""
          echo "å¼€å§‹æ‰§è¡Œåˆ é™¤..."
          SUCCESS_COUNT=0
          FAIL_COUNT=0
          
          for tag in $TAGS_TO_DELETE; do
            echo -n "  åˆ é™¤ $tag ... "
            
            # å…ˆæ£€æŸ¥releaseæ˜¯å¦å­˜åœ¨
            if gh release view "$tag" >/dev/null 2>&1; then
              # Releaseå­˜åœ¨ï¼Œåˆ é™¤releaseä¼šåŒæ—¶åˆ é™¤tag
              if gh release delete "$tag" --yes --cleanup-tag 2>/dev/null; then
                echo "âœ… (release+tag)"
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                echo "âŒ (releaseåˆ é™¤å¤±è´¥)"
                FAIL_COUNT=$((FAIL_COUNT + 1))
              fi
            else
              # Releaseä¸å­˜åœ¨ï¼Œåªåˆ é™¤tag
              if git push origin --delete "$tag" 2>/dev/null; then
                echo "âœ… (ä»…tag)"
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                echo "â­ï¸ (å·²ä¸å­˜åœ¨)"
                FAIL_COUNT=$((FAIL_COUNT + 1))
              fi
            fi
          done
          
          echo ""
          echo "ğŸ“Š æ¸…ç†ç»“æœï¼š"
          echo "- æˆåŠŸåˆ é™¤: $SUCCESS_COUNT"
          echo "- å¤±è´¥/è·³è¿‡: $FAIL_COUNT"
          
          # é‡æ–°è·å–å¹¶æ˜¾ç¤ºä¿ç•™çš„ç‰ˆæœ¬èŒƒå›´
          echo ""
          echo "æ­£åœ¨éªŒè¯æ¸…ç†ç»“æœ..."
          REMAINING_TAGS=$(git ls-remote --tags origin | grep -E 'refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$' | awk '{print $2}' | sed 's|refs/tags/||' | sort -V)
          REMAINING_COUNT=$(echo "$REMAINING_TAGS" | wc -l)
          OLDEST=$(echo "$REMAINING_TAGS" | head -1)
          NEWEST=$(echo "$REMAINING_TAGS" | tail -1)
          
          echo "âœ… æ¸…ç†å®Œæˆï¼"
          echo ""
          echo "ğŸ“Œ å½“å‰ä¿ç•™çš„ç‰ˆæœ¬ï¼š"
          echo "- æœ€æ—§ç‰ˆæœ¬: $OLDEST"
          echo "- æœ€æ–°ç‰ˆæœ¬: $NEWEST"
          echo "- ç‰ˆæœ¬æ€»æ•°: $REMAINING_COUNT"
          
          # éªŒè¯æ˜¯å¦è¾¾åˆ°é¢„æœŸ
          if [ "$REMAINING_COUNT" -le "$TAGS_TO_KEEP" ]; then
            echo "- çŠ¶æ€: âœ… ç¬¦åˆé¢„æœŸï¼ˆâ‰¤$TAGS_TO_KEEPï¼‰"
          else
            echo "- çŠ¶æ€: âš ï¸ è¶…å‡ºé¢„æœŸï¼ˆæŸäº›tagå¯èƒ½åˆ é™¤å¤±è´¥ï¼‰"
          fi
        else
          echo "âœ… å½“å‰tagæ•°é‡ï¼ˆ$TOTAL_COUNTï¼‰æœªè¶…è¿‡é™åˆ¶ï¼ˆ$TAGS_TO_KEEPï¼‰ï¼Œæ— éœ€æ¸…ç†"
        fi

    # Dockeræ„å»ºæ­¥éª¤
    - name: Set up QEMU
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/login-action@v3
      with:
        registry: docker.io
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Log in to GitHub Container Registry
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push Docker image
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ steps.image_names.outputs.docker_image }}:${{ steps.next_version.outputs.new_tag }}
          ${{ steps.image_names.outputs.docker_image }}:latest
          ${{ steps.image_names.outputs.docker_image }}:${{ steps.next_version.outputs.new_version }}
          ${{ steps.image_names.outputs.ghcr_image }}:${{ steps.next_version.outputs.new_tag }}
          ${{ steps.image_names.outputs.ghcr_image }}:latest
          ${{ steps.image_names.outputs.ghcr_image }}:${{ steps.next_version.outputs.new_version }}
        labels: |
          org.opencontainers.image.version=${{ steps.next_version.outputs.new_version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.source=https://github.com/${{ github.repository }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Send Telegram Notification
      if: steps.check.outputs.needs_bump == 'true' && env.TELEGRAM_BOT_TOKEN != '' && env.TELEGRAM_CHAT_ID != ''
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        DOCKER_IMAGE: ${{ steps.image_names.outputs.docker_image }}
        GHCR_IMAGE: ${{ steps.image_names.outputs.ghcr_image }}
      continue-on-error: true
      run: |
        VERSION="${{ steps.next_version.outputs.new_version }}"
        TAG="${{ steps.next_version.outputs.new_tag }}"
        REPO="${{ github.repository }}"
        
        # è·å–æ›´æ–°å†…å®¹å¹¶é™åˆ¶é•¿åº¦
        CHANGELOG="${{ steps.changelog.outputs.content }}"
        CHANGELOG_TRUNCATED=$(echo "$CHANGELOG" | head -c 1000)
        if [ ${#CHANGELOG} -gt 1000 ]; then
          CHANGELOG_TRUNCATED="${CHANGELOG_TRUNCATED}..."
        fi
        
        # æ„å»ºæ¶ˆæ¯å†…å®¹
        MESSAGE="ğŸš€ *Claude Relay Service æ–°ç‰ˆæœ¬å‘å¸ƒï¼*"$'\n'$'\n'
        MESSAGE+="ğŸ“¦ ç‰ˆæœ¬å·: \`${VERSION}\`"$'\n'$'\n'
        MESSAGE+="ğŸ“ *æ›´æ–°å†…å®¹:*"$'\n'
        MESSAGE+="${CHANGELOG_TRUNCATED}"$'\n'$'\n'
        MESSAGE+="ğŸ³ *Docker éƒ¨ç½²:*"$'\n'
        MESSAGE+="\`\`\`bash"$'\n'
        MESSAGE+="docker pull ${DOCKER_IMAGE}:${TAG}"$'\n'
        MESSAGE+="docker pull ${DOCKER_IMAGE}:latest"$'\n'
        MESSAGE+="docker pull ${GHCR_IMAGE}:${TAG}"$'\n'
        MESSAGE+="docker pull ${GHCR_IMAGE}:latest"$'\n'
        MESSAGE+="\`\`\`"$'\n'$'\n'
        MESSAGE+="ğŸ”— *ç›¸å…³é“¾æ¥:*"$'\n'
        MESSAGE+="â€¢ [GitHub Release](https://github.com/${REPO}/releases/tag/${TAG})"$'\n'
        MESSAGE+="â€¢ [å®Œæ•´æ›´æ–°æ—¥å¿—](https://github.com/${REPO}/releases)"$'\n'
        MESSAGE+="â€¢ [Docker Hub](https://hub.docker.com/r/${DOCKER_IMAGE%/*}/claude-relay-service)"$'\n'
        MESSAGE+="â€¢ [GHCR](https://ghcr.io/${GHCR_IMAGE#ghcr.io/})"$'\n'$'\n'
        MESSAGE+="#ClaudeRelay #Update #v${VERSION//./_}"
        
        # ä½¿ç”¨ jq æ„å»º JSON å¹¶å‘é€
        jq -n \
          --arg chat_id "${TELEGRAM_CHAT_ID}" \
          --arg text "${MESSAGE}" \
          '{
            chat_id: $chat_id,
            text: $text,
            parse_mode: "Markdown",
            disable_web_page_preview: false
          }' | \
        curl -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -H "Content-Type: application/json" \
          -d @-